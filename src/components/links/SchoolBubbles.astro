---
interface School {
  avatar: string
  name: string
  intro?: string
  link: string
}

interface SchoolList {
  id_name: string
  desc: string
  link_list: School[]
}

interface Props {
  list: SchoolList
}

const { list } = Astro.props
---

<div class="school-bubbles-container">
  <div id="school-bubbles" class="bubbles-svg-container"></div>
</div>

<script>
  // Load D3 from CDN and initialize the component
  const script = document.createElement('script');
  script.src = 'https://d3js.org/d3.v7.min.js';
  script.onload = function() {
    const d3 = (window as any).d3;
    const container = document.getElementById('school-bubbles');
    if (!container) return;

    // Get school data from the component
    const schoolsData = JSON.parse(document.querySelector('[data-schools]')?.textContent || '[]');
    
    // Responsive bubble sizes - reduced overall size
    const isMobile = window.innerWidth <= 768;
    
    // Set up dimensions - reduced height for more compact layout
    const width = container.offsetWidth || 800;
    const height = isMobile ? 500 : 450; // Reduced height significantly
    const maxRadius = isMobile ? 22 : 32; // Reduced from 30/45 to 22/32
    const minRadius = isMobile ? 15 : 22; // Reduced from 20/30 to 15/22

    // Create SVG
    const svg = d3.select('#school-bubbles')
      .append('svg')
      .attr('width', width)
      .attr('height', height);

    // Create a group for bubbles
    const bubbleGroup = svg.append('g');

    // Prepare data with circular initial positioning
    const nodes = schoolsData.map((school: any, i: number) => ({
      id: i,
      name: school.name,
      intro: school.intro,
      link: school.link,
      avatar: school.avatar,
      radius: minRadius + Math.random() * (maxRadius - minRadius),
      x: Math.random() * width,
      y: Math.random() * height,
      originalRadius: minRadius + Math.random() * (maxRadius - minRadius),
      isHovered: false,
      vx: 0,
      vy: 0,
      targetRadius: minRadius + Math.random() * (maxRadius - minRadius)
    }));

    // Set up force simulation for circular layout with balanced spacing
    const simulation = d3.forceSimulation(nodes)
      .force('charge', d3.forceManyBody().strength(isMobile ? -80 : -150)) // Moderate repulsion for balanced spacing
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide().radius((d: any) => d.radius + (isMobile ? 1.5 : 2))) // Small but visible gap
      .force('x', d3.forceX(width / 2).strength(0.12))
      .force('y', d3.forceY(height / 2).strength(0.12));

    // Create bubble elements
    const bubbles = bubbleGroup.selectAll('.bubble-group')
      .data(nodes)
      .enter()
      .append('g')
      .attr('class', 'bubble-group')
      .style('cursor', 'pointer');

    // Add circle backgrounds
    bubbles.append('circle')
      .attr('class', 'bubble-bg')
      .attr('r', (d: any) => d.radius)
      .attr('fill', 'white')
      .attr('stroke', '#e0e0e0')
      .attr('stroke-width', 2); // Reduced stroke width

    // Add images
    bubbles.append('defs')
      .append('pattern')
      .attr('id', (d: any, i: number) => `school-pattern-${i}`)
      .attr('patternUnits', 'objectBoundingBox')
      .attr('width', 1)
      .attr('height', 1)
      .attr('x', 0)
      .attr('y', 0)
      .append('image')
      .attr('href', (d: any) => d.avatar)
      .attr('x', 0)
      .attr('y', 0)
      .attr('width', (d: any) => (d.radius - 4) * 2) // Reduced padding
      .attr('height', (d: any) => (d.radius - 4) * 2) // Reduced padding
      .attr('preserveAspectRatio', 'xMidYMid slice');

    // Add image circles
    bubbles.append('circle')
      .attr('class', 'bubble-image')
      .attr('r', (d: any) => d.radius - 4) // Reduced padding
      .attr('fill', (d: any, i: number) => `url(#school-pattern-${i})`)
      .attr('stroke', 'white')
      .attr('stroke-width', 1.5); // Reduced stroke width

    // Add tooltip
    const tooltip = d3.select('body')
      .append('div')
      .attr('class', 'school-tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', 'rgba(0, 0, 0, 0.9)')
      .style('color', 'white')
      .style('padding', '8px 12px')
      .style('border-radius', '6px')
      .style('font-size', '12px')
      .style('pointer-events', 'none')
      .style('z-index', '1000');

    // Mouse events
    bubbles
      .on('mouseenter', function(event: any, d: any) {
        d.isHovered = true;
        d.targetRadius = d.originalRadius * 1.2; // Reduced hover scale for less expansion
        
        // Show tooltip
        tooltip.transition()
          .duration(200)
          .style('opacity', 1);
        
        tooltip.html(`
          <div style="text-align: center;">
            <strong>${d.name}</strong>
            ${d.intro ? `<br/><small>${d.intro}</small>` : ''}
          </div>
        `)
        .style('left', (event.pageX + 10) + 'px')
        .style('top', (event.pageY - 28) + 'px');

        // Restart simulation for smooth animation
        simulation.alpha(0.3).restart();
      })
      .on('mouseleave', function(event: any, d: any) {
        d.isHovered = false;
        d.targetRadius = d.originalRadius;
        
        // Hide tooltip
        tooltip.transition()
          .duration(200)
          .style('opacity', 0);

        // Restart simulation
        simulation.alpha(0.3).restart();
      })
      .on('click', function(event: any, d: any) {
        window.open(d.link, '_blank');
      });

    // Update positions on tick
    simulation.on('tick', () => {
      // Update radius with smooth transition
      nodes.forEach((d: any) => {
        const targetRadius = d.targetRadius || d.originalRadius;
        d.radius += (targetRadius - d.radius) * 0.1;
      });

      // Update collision force with new radii
      simulation.force('collision', d3.forceCollide().radius((d: any) => d.radius + (isMobile ? 1.5 : 2)));

      // Position bubbles
      bubbles.attr('transform', (d: any) => `translate(${d.x}, ${d.y})`);
      
      // Update circles
      bubbles.select('.bubble-bg')
        .attr('r', (d: any) => d.radius);
      
      bubbles.select('.bubble-image')
        .attr('r', (d: any) => d.radius - 4);

      // Update pattern size
      bubbles.select('pattern image')
        .attr('width', (d: any) => (d.radius - 4) * 2)
        .attr('height', (d: any) => (d.radius - 4) * 2);
    });

    // Add mouse force for repulsion with reduced range
    svg.on('mousemove', function(event: any) {
      const [mouseX, mouseY] = d3.pointer(event);
      
      nodes.forEach((d: any) => {
        const dx = d.x - mouseX;
        const dy = d.y - mouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        const repulsionRange = isMobile ? 40 : 50; // Moderate range for balanced spacing
        const repulsionForce = isMobile ? 0.7 : 1.0; // Moderate force
        
        if (distance < repulsionRange && !d.isHovered) {
          const force = (repulsionRange - distance) / repulsionRange * repulsionForce;
          d.vx += dx / distance * force;
          d.vy += dy / distance * force;
        }
      });
    });
  };
  document.head.appendChild(script);
</script>

<!-- Embed school data as JSON -->
<script type="application/json" data-schools set:html={JSON.stringify(list.link_list)}></script>

<style>
  .school-bubbles-container {
    width: 100%;
    height: 450px; /* Reduced from 600px to 450px */
    margin: 1.5rem 0; /* Reduced margin */
    overflow: hidden;
  }

  .bubbles-svg-container {
    width: 100%;
    height: 100%;
  }

  .bubble-group {
    transition: all 0.3s ease;
  }

  .bubble-group:hover .bubble-bg {
    filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.15)); /* Reduced shadow */
  }

  .bubble-image {
    transition: all 0.2s ease;
  }

  /* Responsive design */
  @media (max-width: 768px) {
    .school-bubbles-container {
      height: 500px; /* Reduced height for mobile */
      margin: 1rem 0; /* Reduced margin for mobile */
    }
  }
</style> 